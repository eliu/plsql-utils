REFACTOR

This file describes some idea and inspirations on
this package, including designing ideas, APIs and
basic SMTP sending format. And you can also learn 
how to use this package in this file.

Purposes
-------------------------------------------------
1. Support multiple smtp instances to send mails
   independently.

2. Abstract even more friendly APIs

3. support CC, and multi-attachments


Content
-------------------------------------------------
Multi-instance support

In order to make multi instances to be created to
send mail independently, I think a new type called
SMTP_TYPE will be born and should be something
like this:

	TYPE SMTP_TYPE IS RECORD (
		CONNECTION UTL_SMTP.CONNECTION,
		CHARSET	   VARCHAR2(50),
		DB_CHARSET VARCHAR2(50),
		DATA	   BLOB
	);  -- INTERNAL USE ONLY

And a hashtable that keep multi smtp instances is 
something like this:

	TYPE SMTP_TYPE_INSTS IS TABLE OF SMTP_TYPE
		INDEX BY BINARY_INTEGER;
	-- INTERNAL USE ONLY

With these two new types, we can save our new smtp
instances to the hashtable and access them using
number index. Actually when a new connection is 
created, a object index is returned to the caller.
To be friendly, an extra index type should be 
created also:

	SUBTYPE SMTP_CONNECTION IS BINARY_INTEGER;
	-- PUBLIC TO THE CALLERS

Then we can use the following code to instantiate 
smtp objects.

	DECLARE
		smtp_conn1 utl_smtp_helper.SMTP_CONNECTION;
		smtp_conn2 utl_smtp_helper.SMTP_CONNECTION;
	BEGIN
		-- create one smtp connection
		smtp_conn1 :=
		utl_smtp_helper.Create_Smtp_Connection (
			p_smtp_host_name => '<SMTP_HOST1>',
			p_smtp_port_num  => '<SMTP_PORT1>'
		);
		
		-- create another one
		smtp_conn2 :=
		utl_smtp_helper.Create_Smtp_Connection (
			p_smtp_host_name => '<SMTP_HOST2>',
			p_smtp_port_num  => '<SMTP_PORT2>'
		);

		-- ...MORE CODE

		-- Disconnect must be invoked to release
		-- resources each connection has been
		-- taken.
		utl_smtp_helper.Disconnect(smtp_conn2);
		utl_smtp_helper.Disconnect(smtp_conn1);
	END;

	
Abstract Friendy APIs

This time, the main purpose on refacting this package
is to make the APIs more simple and clear. The original
calling interface is like this:

	begin
	  utl_smtp_helper.Set_Encoding('gb2312');
	  -- Call the procedure
	  utl_smtp_helper.send_mail(
			p_smtp_hostname => :p_smtp_hostname,
			p_smtp_portnum => :p_smtp_portnum,
			p_from => :p_from,
			p_sender => :p_sender,
			p_to => :p_to,
			p_receiver => :p_receiver,
			p_subject => :p_subject,
			p_text => :p_text,
			p_html => :p_html,
			p_file_path => :p_file_path,
			p_file_name => :p_file_name
	  );
	end;

Refactored the code, The APIs seems more easily understood
and more flexible. The caller can wrap or organize his
own Send_Mail right now. Here is my basic abstractions.

	DECLARE
		smtp_conn utl_smtp_helper.SMTP_CONNECTION;
	BEGIN
		-- create one smtp connection
		smtp_conn :=
		utl_smtp_helper.Create_Smtp_Connection (
			p_smtp_host_name => '<SMTP_HOST>',
			p_smtp_port_num  => '<SMTP_PORT>'
		);
		
		-- Set mail header
		utl_smtp_helper.Set_Header (
			p_smtp_conn		=> smtp_conn,
			p_from			=> 'foo@hostname.com',
			p_sender		=> 'Foo',
			p_to			=> 'bar@hostname.com',
			p_receiver		=> 'Bar',
			p_cc1			=> 'cc1@hostname.com',
			p_cc2			=> 'cc2@hostname.com',
			p_subject		=> 'Subject',
			p_charset		=> 'UTF-8',
			p_db_charset	=> 'UTF8'
		);

		-- Append mail body
		utl_smtp_helper.Add_Body (
			p_smtp_conn		=> smtp_conn,
			p_content_type  => utl_smtp_helpr.HTML_CONTENT,
			p_body			=> 'HTML Body'
		);
		-- or adding plain text body
		/*
		utl_smtp_helper.Add_Body (
			p_smtp_conn		=> smtp_conn,
			p_content_type  => utl_smtp_helpr.TEXT_CONTENT,
			p_body			=> 'HTML Body'
		);
		*/

		-- add attachments
		utl_smtp_helper.Add_Attachment(
			p_smtp_conn		=> smtp_conn,
			p_file_path		=> '/usr/tmp',
			p_file_name		=> 'filename.ext'
		);
		-- or add multi attachments in the same base path
		/*
		utl_smtp_helper.Add_Attachments(
			p_smtp_conn		=> smtp_conn,
			p_file_path		=> '/usr/tmp',
			p_file_name1	=> 'filename1.ext',
			p_file_name2	=> 'filename2.ext',
			p_file_name3	=> 'filename3.ext'
		);
		*/
		
		-- send email now
		utl_smtp_helper.Send(
			p_smtp_conn		=> smtp_conn
		);

		-- Disconnect must be invoked to release
		-- resources each connection has been
		-- taken.
		utl_smtp_helper.Disconnect(smtp_conn);
	END;


Appendix
---------------------------------------------------
There is a sample data format that is used to send
SMTP mail.
<CRLF> is the sign that indicates the CARRIAGE RETURN
+ ENTER

MIME-Version: 1.0<CRLF>
Date: 14 6ÔÂ  11 09:27:04<CRLF>
To: "Receiver"<recv@hostname.com><CRLF>
From: "Sender"<send@hostname.com><CRLF>
Subject: subject<CRLF>
Reply-To: send@hostname.com<CRLF>
Content-Type: multipart/mixed; boundary="DMW.Boundary.605592468"<CRLF>
<CRLF>
<CRLF>
--DMW.Boundary.605592468<CRLF>
content-type: text/plain; charset=utf-8<CRLF>
<CRLF>
This is the text body.<CRLF>
<CRLF>
<CRLF>
--DMW.Boundary.605592468<CRLF>
content-type: text/html; charset=utf-8<CRLF>
<CRLF>
<!doctype html>
<html>
       <head>
          <title>' || p_title || '</title>
          <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
       </head>
       <body>
         <h1>This is the html body.</h1>
       </body>
</html><CRLF>
<CRLF>
<CRLF>
--DMW.Boundary.605592468<CRLF>
Content-Type: application/octet-stream; name="filename.ext"<CRLF>
Content-Disposition: attachment; filename="filename.ext"<CRLF>
Content-Transfer-Encoding: 7bit<CRLF>
<CRLF>
[FILE_DATA]<CRLF>
<CRLF>
<CRLF>
--DMW.Boundary.605592468--<CRLF>
<CRLF>